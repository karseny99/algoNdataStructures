Традиционно использовались однобайтные кодировки, то есть знак кодировался двумя
шестнадцатиричными числами. 


ASCII (American Standard Code for Information Interchange)
Кодировка ASCII использует для кодирования только 7 бит. Первая цифра нахоится в диапазоне 0-7 (а не 0-F). 
Так таблицу можно разделить на две половины: первая половиная (ряды 0-7), это байты с нулевым старшим битом, 
а вторая половина - со старшим битом равным  1.  Это удобно для ascii-совместимых
кодировок: ascii  в первой половине, а вторая для региональных алфавитов и т.п.
Сначала расположены управляющие символы, затем цифры и знаки препинания, потом заглавные буквы,
потом строчные (только латинский алфавит).


EBCDIC (Extended Binary Coded Decimal Interchange Code) Восьмибитная кодировка, основанная
на шестбитной кодировке BCDIC. В первой половине таблице всегда служебные символы,
и немного пунктуации. Все буквы во второй половине. Такое кодирование пришло из 
перфокарт. В кодировке EBCDIC много свободных мест, но они не расположены так удобно, 
как в ASCII, из-за чего создание национальных кодировок не так очевидно и удобно, как 
на основе ASCII. Кроме того, ECBDIC имеет множество несовместимых между собой вариаций.



ДКОИ-8 
8 бит, основана на EBCDIC (добавлена кириллица). Почти все буквы и цифры во второй
половине таблицы. ё Ё Ъ нет. ДКОИ, как и ECBDIC, почти не применяются сейчас.



КОИ-7 
Семибитная кодировка, все русские буквы находятся в первой половинe таблицы, 
то есть с ASCII не совместима. Имеет три варианта:
Н0 - английские буквы как в ascii, русских нет. Почти ASCII, но доллар изменен на знак валюты.
H1 - есть русский буквы, но нет английских. Русские буквы стоят на местах, похожих по звучанию 
с английскими.
H2 - есть английские заглавные и русские заглавные (стоят на месте строчных английских). 
 


КОИ-8
Совместима с ASCII, русские буквы стоят на своих аналогах латинских. 
Существует много вариаций KOI8: koi8-R, koi8-U и т.д.
Была главной кодировкой руссифицированных дистрибутивов linux, 
широко применялась в web.



Основная кодировка
Совместима с ASCII, разработана в 1986году в ВЦ Академии Наук СССР. 
Мало где применялась. Буквы ё и Ё выпали из алфавитного порядка 
(имели коды больше, чем буква Я).



Альтернативная кодировка
Совместима с ASCII, основана на CP437. Европейские знаки заменены
на кириллицу, псевдографика из CP437, осталась на своих местах. 
Существовало несколько вариантов, стандартом стала IBM CP866,
поддержка которой была в MS-DOS. 



Windows-1251
Совместима с ASCII. Создана на основе самодельных руссификаций windows 1990-1991 годов.
Часть семейства кодировок windows для кириллических письменностей.
 
Достоинства: есть почти все знаки русской типографики (кроме ударений);
есть все знаки русского, украинского, белорусского, сербского и болгарского алфавитов.

Недостатки: нет псевдографики, буква "я" имеет код 255, который мог 
значить -1 в дополнительном коде. А -1 часто использовалось, как
спец. значение, например EOF.



UNICODE
Призван заменить разнообразие кодировок. Разрабатывался с 1991 года. 
Первоначально предполагалось кодировать буквы двумя байтами, 
но развитие юникода этим не закончилось. Юникод стал стандартом 
кодирования текста, включающим в себя набор знаков с номерами и именами(UCS),
а также: 
1) Правила нормализации (привидение к стандартной форме)
2) Правила двунаправленного письма
3) Соответствие модифицированных символов немодифицированным
и т.д.

Universal Character Set (UCS) - таблица соответствия числового кода
знаку, имеющему название и графическое изображение. В UCS входит ~100 000 знаков.
Отдельный знак в таблице называется code point и обычно записывается как 16ричное 
число с префиксом U+.

BMP (Basic Multilingual Plane) - первые 65536 знаков, включающие наиболее
часто используемые знаки и до 2000 года в основном использовалась только эта часть юникода.

На основе UCS сделано множество кодировок, которые делятся на два типа:
1) UCS-* - прямая запись кодпоинта записывается целым числом. UCS-4: каждая буква - 
четырехбайтное целое, код из UCS. Множество кодируемых букв ограничивается плоскостью BMP.
2) UTF-* - кодировки, в которых для получения code point, надо сделать какие-то преобразования


Code unit - атомарный элемент конкретной кодировки. Например, в UTF-16 - это двухбайтовое число,
в UTF-32 - четырехбайтовое целое, а в UTF-8 просто один байт.


UTF-16
Часть знаков кодируется как в UCS-2, остальные более сложно, парами. В диапазоне UCS-2 неиспользуемое 
пространство U+D800..U+DFFF, которое разбили на две равные части(High Surrogates
U+D800..U+DBFF и Low Surrogate U+DC00..U+DFFF). Для кодирования знаков, которые не влезли в UCS-2
используется сочетание из двух значений: High Surrogates и Low Surrogates. То есть UTF-16 имеет 
переменную длинну знаков

Проблемы:

UNICODE BOM
Для кодировок, использующих целые длиной больше одного байта характерна проблема
порядка байт. Архитектуры размещают байты в памяти по-разному: от старшего к младшему,
от младшего к старшему. 
Поэтому применяется специальная Byte Order Mask - метка порядка байтов.
Метка - есть знак неразрывного пробела нулевой ширины. В юникоде это U+FEFF.

2) Нулевые байты. Си-программы не могут прочитать строку в этих кодировках, тк
считают нулевой байт за окончание строки.

3) Потеря байта ломает не одну букву, а весь текст после

4) Несовместимость с ASCII

5) Нельзя выяснить длину текста в буквах, зная только длину текста в байтах.

Последняя проблема не решаема, а для остальных решением стала UTF-8.



UTF-8
Знаки ASCII кодируются один-в-один одним байтом.
0xxxxxxx - знаки из ASCII
Остальные code point кодируются несколькими байтами,
первый из которых дополнительно кодирует длину:
110xxxxx - всего будет два code unit (байта), в первом байте 
5 бит полезной нагрузки
Сколько единиц в начале - столько байтов и будет использовано для кодирования.

Достоинства:
1) Совместима с ASCII
2) Нулевых байтов внутри текста нет, кроме ASCII нулевого байта
3) Порядок байтов в целых числах не важен
4) После потери/искажения байта легко найти начало следующей буквы
5) Быстрая: все операции для раскодирования - битовые сдвиги и маски.




















































