Отладка средствами стандарта языка



--- Этапы компиляции ---

1) Этап препроцессора

На этом этапе производится работа с препроцессорными директивами 
(Директивы представляют собой инструкции, записанные в тексте программы)
Например, #include включает содержимое указанного файла,
заменяет макросы #define их значениями, 
обрабатывает директивы условной компиляции #if, #ifdef, #endif, убирает комментарии

Чтобы скомпилировать до этого этапа нужно использовать ключ -E


Можно вызвать ошибку на этом этапе, например, при работе с неверной препроцессорной
директивой: #including <stdio.h>


2) Компилятор Си

Компилятор берет файл, без директив и комментариев после прошлого этапа, 
и преобразует его в ассемблерный код. Это промежуточный этап между 
высокоуровневым языком и машинным кодом. 

Чтобы скомпилировать до этого этапа нужно использовать ключ -S

Можно вызвать ошибку, допустив ошибку в синтаксисе.
Также ошибка будет при использовании несуществующего типа
 и работе с необъвленной переменной.

3) Ассемблер 

На этом этапе ассемблерный код преобразуется в машинный. Сохраняется машинный код
в объектный файл. Объектные файлы представляют собой блоки машинного кода и данных,
 с неопределенными адресами ссылок на данные и процедуры в других объектных модулях, 
а также список своих процедур и данных. 

Чтобы скомпилировать до этого этапа нужно использовать ключ -c

Можно вызвать ошибку, используя ассемблерную вставку несуществующих ассемблерных 
инструкций. 

4) Линковщик

На этом этапе компиляции происходит получения исполняемого файла, 
состоящего из связанных вместе всех объектных файлов проекта и статических библиотек.
Тут принудительно линкуются с файлом еще набор стартовых программ crt0/crt1.

Можно вызвать ошибку, сославшись на объявленную, но не определенную функцию,
а также можно объявить и определить две одинаковые функции в двух файлах, 
скомпилировать их вместе и получить ошибку только на этапе линковке, так как
компиляция файлов производится независимо. 

5)  Runtime

Вызываем загрузчик для загрузки скомпилированной программы в память. 
Здесь возможна подгрузка динамических библиотек. 

Для вызова ошибки можно в программе обратиться к несуществующему элементу массива
Или, например, поделить на ноль.




--- Отладка ---

Для отладки программы нужно её скомпилировать с ключом -g
 для генерации отладочных файлов.

А затем запустить командой
>>>gdb ./a.out


Запустив отладчик, командой list можно вывести программу 
break/b <номер> - задание точки остановки на указанной строке
run/r - запуск программы на выполнение (остановится на ближайшем breakpoint'e, если он есть)
next/n - выполняет всё до следующей строки (если есть breakpoint - остановится на нем)
step/s - выполняет программу пошагово (заходит и внутрь вызванных функций)
contninue/c - продолжить выполнение программы после остановки
print/p - распечатать значение выражения (переменные, вызов функций)

backtrace/bt - Выводит текущее состояние стека вызовов - (какие функции находятся, 
какие выполняются) 

/*

Стек вызовов - сегмент памяти, который хранит фрейм под каждый вызов функции
Фрейм - участок памяти, который выделяется на один вызов функции. 
Хранит локальные переменные и адрес, откуда продолжим выполнение, когда закончим тут

*/




--- Сеть ---

Протокол TCP/IP (Transmission Control Protocol & Internet Protocol)
 – это сетевая модель, описывающая способ передачи данных в цифровом виде. 
Сюда входит формирование пакетов, способ их отправки, маршрутизация, 
распаковка для обработки ПО. 

Протокол имеет 4(5) уровня:


0) Физический уровень
	
	Определяет электрические и физические характеристики соединения данных
	(Напр., напряжения кабеля, частоту беспроводных устройств). 
	Он отвечает за обмен физическими сигналами между физ. устройствами. 


1) Канальный (сетевой интерфейс)
	
	Обеспечивает взаимодействие сетей на физическом уровне
	и контролирует возникающие ошибки. Также уровень решает проблему
	адресации при передаче информации. Полученные с физического уровня данные
	упаковываются в фреймы, проверяется их целостность и исправляются, если нужно,
	ошибки (путём повторного запроса для не целого фрейма), затем они отправляются
	на сетевой уровень. 
	
	Канальный уровень подразделяется на два подуровня:
	1) уровень Media Access Control (MAC) layer 	(нижний)
	2) logical link control (LLC)	 (верхний)

	-- MAC обеспечивает адресацию и механизмы управления доступом к каналам. 
	-- LLC осуществляет:
		1) управление передачей данных
		2) Проверку и правильность передачи данных в сети 
	

2) Сетевой уровень (Протокол Internet)

	Сетевой уровень отвечает за объединение локальных сетей в глобальную. 
	Сетевой уровень также отвечает за адресацию хостов, упаковку и функции маршрутизации.
	


3) Транспортный уровень

	Этот уровень обеспечивает функции доставки пакетов. На этом уровне работают протоколы TCP и UDP.
	Первый устанавливает соединение между двумя хостами
 	и гарантирует передачу данных в полном объеме без потерь (Если часть информации теряется, 
	то протокол запрашивает ее повторно). 

	User Datagram Protocol (UDP) не устанавливает соединение между хостами, а передает автономные датаграммы. 
	В процессе передачи часть данных может потеряться, но контроль целостности не производится, 
	благодаря чему достигается высокая скорость, в ущерб надежности. 

4) Прикладные протоколы

	Уровень соответствует трем верхним уровням модели OSI: прикладной, представительный, сеансовый.
	Здесь работает большинство сетевых приложений. Эти программы имеют свои протоколы обмена  данными:
	HTTP для WWW, FTP - передача данных, SMTP - эл. почта, 
	а также для динамического назначения адресов в сети применяется набор правил, определенных протоколом DHCP.


	
Главное отличие OSI и TCP/IP заключается в том, что OSI имеет строгую иерархию, 
из-за которой в уровень нельзя добавить какой-нибудь протокол, например, QUIC, 
работающий на транспортном уровне и реализованный поверх UDP.

Таким образом, в OSI функция каждого уровня должна быть выбрана в соответствии
с международным стандартом, а также каждый уровень в этой модели опирается
на предыдущий, более низкий.  В TCP/IP можно внедрять бесплатно, а чтобы использовать стандарты OSI, 
производители должны покупать бумажные копии стандартов. 


	


--- DNS & NAT ---

Domain Name System (DNS), необходим для соотнесения IP-адресов 
устройств в сети и символьных имён, то есть решает 2 задачи
1) google.ru -> 2.3.4.5
2) 2.3.4.5 -> google.ru

Структура DNS состоит из распределенной
базы имен, называемомй пространством имен домена. Её структура схожа с деревом,
где каждый узел имеет свое уникальное имя. 
Корневой домен (самый верхний уровень иерархии DNS) обозначается точкой. 


		--------"."/" "-----------------
	       /       /    \          \      \
	      ...   ".ru"  ".com"  	      ..
		    /	\       \
		"ya.ru"  ..     ...	
		/     \
	 "mail.ya.ru"  ..	




Network Adress Translation (NAT) 
NAT переводит приватные адреса, в общедоступные. Это позволяет устройству
обращаться за пределы его частной сети. 

NAT принимает данные от локального компьютера и проверяет куда нужно отправить.
Если отправка не в локальную сеть, то NAT подменяет локальный IP адрес на свой внешний,
меняет номер порта, чтобы отправлять пакеты приема нужным устройствам в сети.

Для отправки полученного пакета соответствующему устройству роутер берет
нужный локальный адрес из временной NAT-таблицы. 

Таким образом, NAT решает проблему нехватки IP адресов, 
а также обеспечивает сетевую безопасность, т.к. , условный,
yandex.ru посылая ответный пакет, посылает его на NAT, при этом
не зная конечного получателя. 



--- Сетевые топологии --- 
Сетевая топология — способ описания конфигурации сети, 
схема расположения и соединения сетевых устройств

1) Топология с общей шиной
	Суть: к одному кабелю присоединяются все устройства,
	образуя локальную сеть. На концах кабеля были терминаторы.
	Преимущество только в простоте установки. 
	Если где-то разрыв в кабеле, то вся сеть рушится.

2) Кольцевая топология
	Суть: каждое устройство подключается к 2ум соседним, образуя кольцо.
	Так, устройство с одного конца только отправляет, а устройство с другого
	только принимает, то есть все остальные являются ретрансляторами сигнала.
	-> Терминаторы больше не нужны.
	Та же проблема: повреждение кабеля убивает всю сеть. 
	Для надежности делали двойное кольцо, т.е. два кабеля в каждое устройство.

3) Топология звезда
	Суть: все устройства подключены к центральному узлу, который является
	ретранслятором. Иногда используется в локальных сетях при подключении 
	устройств к центральному узлу, который является посредником при передаче.
	Более надежнее предыдущих, т.к. при повреждении одного кабеля отключится
	1 устройство, но при повреждении центрального узла все умрет. 
	
4) Смешанная топология
	Суть: древовидная структура, самая надежная, т.к. при повреждении
	кабеля в одном месте, другие участки продолжают работать. 
	В данный момент самая используемая топология. 





--- Сетевые устройства ---

1) Hub ( Данные передает по MAC адресу )
	Транслирует пакеты, поступающие на один из портов
	на все остальные. Работает на физическом уровне OSI. 
	Из-за копирования пакетов во все порты работает медленно. 
	
2) Switch ( Данные передает по MAC адресу )
	Передает данные от одного порта к другому 
	на основании информации из пакета.
	Работает на канальном уровне OSI.
	
3) Router ( Данные передает по IP адресу ) 
	Служит для передачи пакетов между устройствами 
	на основе каких-либо правил. 
	Работает на сетевом уровне OSI.
	Роутер выбирает оптимальный маршрут передачи
	между нужными устройствами. 
	Имеет таблицы маршрутизации, которые содержат информацию	
	обо всех возможных маршрутах передачи пакетов с доп. инфой
	о состоянии канала, загруженности и тп.

Шлюз по умолчанию (англ. Default gateway) — в маршрутизируемых протоколах — сетевой шлюз, 
на который пакет отправляется в том случае, если маршрут к сети назначения пакета не известен 
(не задан явным образом в таблице маршрутизации хоста)



--- IEEE754 ---




-- Погрешность --   
 
На каждом промежутке с порядком 0, 1, 2, ... [1, 2) ; [2, 4) ; [4, 8); ... лежит 2 ^ 23 чисел 
=> мы получаем, что, например, промежуток [1, 2) имеет длину интервала меж. чисел равную 
(2 - 1) / 2 ^ 23 = 2 ^ (-23), а промежуток [4, 8) имеет длину (8 - 4) / 2 ^ 23 = 2 ^ (-21) 
Отсюда получается, что числа на промежутке распределены равномерно, но длина между соседними разная
и увеличивается с ростом порядка.

Это расстояние между числами - есть погрешность представления: она больше на больших порядках
и меньше на маленьких. Абсолютное значение погрешности меняется с изменением порядка,
а относительная погрешность остается равной машинному эпсилон для данного типа.

Абсолютная погрешность вычисляется так: 2 ^ (порядок - 23) 



-- Денормализованные числа --
(Для float 1 + 8 + 23):
Порядок 0..0 имеет спец. смысл. Числа с этим порядком представляются не в нормализованном виде.
Например, 1.0 * 2 ^ (-127) записывается [0|0..0|10..0] -> единица, которая ранее выкидывалась
теперь есть в мантиссе.
Также, 1.0 * 2 ^ (-128) -> [0|0..0|010..0]

Денормализация чисел нужна для устранения дыры в множестве чисел около нуля (Underflow Gap).
Т.к., если, например, взять A = [0|0..0|0..01] = 1.0..01 * 2 ^ (-127) = 2 ^ (-127) + 2 ^ (-127-23) - минимальное положительное
и B = [0|0..0|0..010] = 1.0..010 * 2 ^ (-127) = 2 ^ (-127) + 2 ^ (-127-22) - следующее после мин-а
=> число C = B - A  - вообще не представимо, а погрешность измерений у нуля, наоборот, растет, хотя должна уменьшаться
 => денормализация дает нам заполнение промежутка чисел у нуля и решает проблему.









